# 今日大纲：
"""
1. is == id 用法
2. 代码块
3. 统一代码块下的缓存机制
4 不同代码块下的缓存机制（小数据池）
5 总结
6 集合
7 深浅copy
"""
# 昨日回顾
"""
1. 字典：
        查询速度快；（键值对形式，数据之间有关系）  键一定是可哈希的 int str bool tuple
        值：  任意数据类型
        字典（3.5之前无序，3.6x按照初始时的顺序排列，3，7之后有序）
    增删改查：
        增： .setdefault()   有则不变，无则增加  或 直接取 dic['键名‘]=键值  无则增加，有则修改
        删除 ：  .pop()   del   .clear 
        改：    就是增中的改  。      .update()
        查询：   .get()   dic[key]   dic.keys()  dic.values()   dic.items()
    字典的嵌套：
    
内容补充：
    列表：
            .reverse()   反转。主要用于对列表进行反转输出。
            .sort(reverse=True) 从大到小         ,支支持数字类型的
            .sort(reverse=False)   从小到大。              
          
"""
li=[1,2,3,{1:34,'name':'zhangsan '}]
li.reverse()
print(li)
li=[3,56,2,5,2,1]
print(list(set(li)))
print(li)

li.sort(reverse=False)
print(li)
print()
# 具体内容
""""
is  id ==   ：
        id 身份证号： （内存地址） 
        == 用于比较值是否相等
        is  用于判断内存地址是否相同    print(l1 is l2)  返回值是bool类型
        id 相同，那么值一定相同，但是值相同，id不一定相同
"""
s1='name'
s2='name'
print(s1==s2)
print(id(s1))
print(id(s2))
print(s1 is s2)
print()
"""
面试题；      同一代码块使用一个缓存机制，不同代码块之下利用的是不同的缓存机制 （小数据池），
            注意小数据池的范围以及缓存机制的优点。


代码块：
        python程序是由代码块构造的，块是一个python程序的文本，也是作为一个单元执行的
        代码块：一个模块，一个函数，一个类，一个文件都是代码块
        作为交互方式输入的每个命令都是一个代码块
        交互方式： 在解释器界面中输入的每行代码
        对于一个文件中的两个函数，是两个不同的代码块。

两个机制： 同一个代码块下，有一个机制，不同的代码块之下，遵循另一个机制

同一代码快下的缓存机制：
    python在执行同一个代码块的初始化对象命令时，会检查其值是否已经存在，如果存在，会将其重用。
    换句话说：在执行同一个代码块时，遇到初始化对象的命令时，会初始化这个变量与值存储在一个字典中，在遇到新的变量时，
            先在字典中查询记录，如果有相同的记录那么
            他会重复使用这个字典中的这个之前的值，所以上面的例子中，s1,s2的内容在内存中直指向一个地址。
            ===================================>>>> 节省时间，提升性能。
    适用的对象： 可哈希的数据类型。  int bool str 
            细则： 所有的数字，bool数值，几乎所有的字符串。   用id 查看

不同代码快下的缓存机制：  （小数据池）
    python自动将-5~256的整数进行了缓存，当你将这些整数赋值给变量时，并不会重新创建对象，
    而是使用已经创建好的缓存对象（注意好整数的范围）
    python将一定规则的字符串留在 字符串驻留池 中，创建一份，当你将这些字符串赋值给变量时，
    并不会重新创建对象，而是使用在字符串驻留池中创建好的字符串
    
    具体细则： -5~256  bool 满足规则的字符串。
    
    无论是缓存还是字符串驻留池，都是python的优化，即将-5~256的整数和一定规则的字符串，放在一个池（容器或字典）中，
    无论程序中的哪些变量滞箱这些范围内整数或字符串，那么他直接在这个’池‘中引用。
    
    # 字符串:
    #     1.字符串在做乘法的时候总长度不能超过20,进行驻留   # 记住
    #     2.自己定义的字符串 长度不限制 字符串必须(字母,数字.下划线)组成,进行驻留
    #     3.特殊字符(中文除外)定义1个时候,进行驻留
    #     4.字符串*1 其实就是赋值
    

# 15.看代码写结果并解释原因
#  都是True.数值相等。==       由于同一代码快的缓存机制。  
            （很快打脸了，。。。。第二个是错的）  注意一下缓存机制针对的具体细则： 一定是可哈希的。。。。。。

v1 = {'k1': 'v1', 'k2': [1, 2, 3]}
v2 = {'k1': 'v1', 'k2': [1, 2, 3]}
# 首先，对比两个字典，数值是一样的，但是，由于字典是可变的，不满足 
                  同一代码块下的缓存机制（ int bool 几乎全部字符串） 。所以，首先二者的地址一定不同，
# 其次 ，对于字典中的可哈希的元素，那么，他们最终指向的地址是一致的。对于不可哈希的元素，指向的地址也不一致。
# 谈到这里，那么注意一下深浅copy，对于不可哈希的变量，那么里面的不可哈希的元素，
            指向的地址： 深copy 是不同的， 但是浅copy是一致的，可以同步修改。
result1 = v1 == v2
result2 = v1 is v2
print(result1)
print(id(v1),id(v1['k1']),id(v1['k2']),id(v2),id(v2['k1']),id(v2['k2']))
print(result2)           
# 对比两个字典的存储地址。 （这是深copy）一定要注意，对于可变的数据类型，不可哈希，那么他们的地址一定是不同的。
    
"""
i=800
j=800
print(i is j)   # 因为这是同一代码块之下，所以一直

a = "12345678912345678qwertyuioqwertyuioQWERTYUIOWERTYUIOQWERTYUIOasdfghjksdfghjk____asdgadsfasdfgasdgasdgfsdaf"
b = "12345678912345678qwertyuioqwertyuioQWERTYUIOWERTYUIOQWERTYUIOasdfghjksdfghjk____asdgadsfasdfgasdgasdgfsdaf"
print(a is b)     #  自定义的字符串都驻留
print()
"""""
集合：     
        python基础数据类型之一：  set  容器型的数据类型。（dic  list tuple set)     
        里面的数据元素是不可变的（可哈希），但是它本身是可变的（不可哈希）数据类型，而且集合是无序的。     
        
        表示方法：  {}   键值对：  字典   一个个的元素，那么就是集合
        
        集合的作用： 
                列表的去重；
                关系测试：交集，并集，差集。。。。。
    
"""
# 集合的创建
s=set({1,2,3,'barrae','time '})     # set expected at most 1.txt argument
print(s)
s=set([2,'try','do'])
print(s)
s={'吴佩琦',False,1,2,'alex'}    # 无序的
print(s)

s=set()   # 空集合，不然 {}是字典
print(s,type(s),{},type({}))

print()
""""
# 集合要求其内的内容一定是不可变的，即可哈希的
# s={[1,2,3],{'name':'kevin'}}    unhashable type: 'list'
# print(s)
"""

"=======================================增删改查============================="
'==================================增==========================='
s1=set([1,0,12,'tx',3,'taibai'])   # 无序性
print(s1,type(s1))
print(" ================.add('xx')============ "    )
s1.add('time')
print(s1)

print(" ================.update('xx')  迭代着增加============ "    )
s1.update('saogkasl')
print(s1)
print()

'==================================删==========================='
print('============ .remove(元素) 按照元素删除，因为集合无序，所以不能按照索引 ============')
s1.remove(1)
print(s1)

print('============ .pop() 随机删除，因为集合无序，所以不能按照索引 ============')
print(s1.pop())
print(s1)
print()

'==================================改，本来集合可哈希，（不可修改）没有索引，无法修改，==========================='
'============ 集合里面的元素无法修改，但是集合可以变相改值 ============'
s1.remove('s')
s1.add('tuo')
print(s1)


'==================================交集 并集 差集.....==========================='
'============交集  &   .intersection(s2) ============'
s1={1,2,3,4,5}
s2={2,4,5,78,111}
print(s1 & s2)
s3={111,3}
print(s1.intersection(s2))
print()

"============并集  |   .union()  ============"
print(s1|s2)
print(s1.union(s3))
print()

"============差集  -    .difference()  ============"
print(s1-s2)
print(s2.difference(s3))
print()

"============反交集  ^    .symmetric_difference()  ============"


"============子集    <  .issubset()     超子集   >   .issuperset() ============"

'==================================集合的去重========================================='
li=[1,2,3,1,2,3,1,3,5,3,6,7]
set1=set(li)
print(set1)
li=list(set1)
print(li)
print()

print('==================================  深浅copy  ===========================')

# 赋值运算：    完全复制过去，地址指向了同一个，如果有修改，则是对两个变量一起修改，（因为地址是一个）例如赋值运算
l1=[1,2,3,[33,44]]
l2=l1             # 变量的赋值运算，但是指向的是同一个地址，所以修改的时候，是一起修改的。
l1.append(666)
print(l1,id(l1),l2,id(l2))
print()

"""
浅copy：
        .copy()  ,对于整个变量而言，他们在内存中使用了两个地址，不是一个存储空间。
                    但是，但是，但是 对于变量里面的 共有的具体元素而言，通过整体变量不同的内存地址，
                    他们指向了同一个地址。。。。。。。。。。。对于可变的数据类型，可以对他们进行同步的修改。。。。
                    但是，对于不可变的数据类型，相当于将原来通过不同变量地址 指向共有元素地址的指针给修改了，将原来
                    指向不可变的共有元素的地址的指针指向了新值的这个地址。进行的操作不是同步的了。
"""
print()
print('=====================浅copy 注意理解=================')
l4=[1,2,3,[33,44]]
l5=l4.copy()             # 里面的原来的元素指向的是同一个内存地址，但是针对整个列表来说，指向的是不同地址
print(id(l4),id(l5))
l4.append(666)
print(l4,id(l4),l5,id(l5))
print(l4,id(l4),l5,id(l5))
print()

print('可以看到，对于变量里面公用的具体的元素，指向的是同一个地址，类似于指针的思想',id(l5[2]),id(l5[2]))
print('那么对于共有元素，那么里面的元素的地址都是一样的')
print('但是对于可变的数据类型，如果采用非赋值的方法对他们的共有元素进行了修改，那么两个都发生变化，'
      '但是,如果对于不可变的数据类型，直接进行了修改，那么，只会对其中一个变量进行修改。')
l5[-1].append(90)
print(l4,l5)   # [1, 2, 3, [33, 44, 90], 666] [1, 2, 3, [33, 44, 90]]
l4[3].remove(33)
print(l4,l5)
print()

l4[0]=90
print(l4,id(l4[0]),l5,id(l5[0]))
l4[3][0]=20
print(l4,id(l4[0]),l5,id(l5[0]))

l1 = [1,2,3,[4,5,6]]
l2 = l1.copy()
l2[-1] = 77
print(l1)
print(l2)
print()

"""
深copy:
       形式：  copy.deepcopy(name)
        原本：   两个变量对应不同的内存地址，里面相同的元素对应的也是不同的内存地址。
        但是： python做了优化，将可哈希（不可变）的数据类型指向了同一个地址，对于可变的数据类型指向不同的内存地址。
        也就是说，对于可变的数据类型进行修改，那么不会对另一个变量也进行修改。
"""
# 深copy
import copy

li = [1,2,3,[22,33]]
li2 = copy.deepcopy(li)

print(li,id(li),li2,id(li2))
li[-1].append(666)
print(li,id(li),li2,id(li2))

print(li[-1],id(li[-1]),li2[-1],id(li2[-1]))
print(li[0],id(li[0]),li2[0],id(li2[0]))

li[0]='修改后'
print(li[0],id(li[0]),li2[0],id(li2[0]))

# 相关面试题：  这个考察的本质就是 赋值运算时候copy   考察的是copy的深浅
print()
l1=[1,2,3,[22,33]]
l2=l1[:]
l1[-1].append(666)
print(l1,id(l1),l2,id(l2))
# 浅copy ：  嵌套的可变的数据类型是同一个
# 深copy : 嵌套的可变的数据类型不是同一个。

# 深浅拷贝怎么用?
dic = {}   # 'v':4
li = []
for i in range(0,5):
      dic['v']=i
      li.append(dic)
print(li)
# [{'v': 4}, {'v': 4}, {'v': 4}, {'v': 4}, {'v': 4}]
#  因为指向了同一个地址了，list 取地址的时候，取的也是同一片地址。所以修改的时候也被一起修改了。

# 反思一下这两种循环内和循环外的区别：
print()
li = []
while 1:
      username = input('请输入用户名>>> ')
      if username.upper()=='N': break
      password = input('请输入密码 >>> ')
      dic = {}
      dic['username'] = username
      dic['password'] = password
      li.append(dic)
print(li)


li = []
dic = {}
while 1:
      username = input('请输入用户名>>> ')
      if username.upper()=='N': break
      password = input('请输入密码 >>> ')

      dic['username'] = username
      dic['password'] = password
      li.append(dic)
print(li)