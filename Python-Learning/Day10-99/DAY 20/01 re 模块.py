"""
========================================= 昨日回顾 =========================================

=========================================  今日大纲 =========================================
re 模块：
    findall: *****
    search:   *****
    split:  ***
                根据正则表达式的匹配规则，将字符串分割开来。剩余的部分存入列表中。
                个正则表达式加上分组，那么就是将 分组得内容也加上
                                例如例一
                那么为什么字符串的切割，没有保留元字符，但是正则里面能够把东西保留下来呢？
                        正则表达式是按照规则切分的，他并不知道内容是什么，所以，会将内容保留下来

    sub: ***  例二
            替换的方法
            re.sub('正则表达式','需要实现的字符',str,替换的次数)

    subn:   *** 也是替换，返回一个元组  不能指定参数
                (替换后的结果，替换的次数)

    match: ****     相当于从头开始找，看是否有符合规则的字符串，一定是从头开始的
                    等价于   == re.search('^正则表达式',str)
                    虽然等价于srarch,但是当 对内容严格要求的时候，一般都是 match
                    表明的是两种不同的思路：

    compile:    *****   ----节省时间
             性能：
                时间：     你要完成一个功能所需要的代码行数；在执行代码的工作工程中，底层程序是如何工作的。
                          列表不能用 insert    从存储地址来看的。因为插入数据之后或者从前面删除数据之后，
                          列表不能用 pop(n)    会导致 后面存储的数据都会相应的移动数据的存储地址。。。危险！！！
                空间：
                          占用了宝贵的内存条资源
                          影响程序的执行效率
             用户体验

             加入同一个正则表达式要被使用很多次，那么，我们直接先对该正则表达式进行编译。
             节省了多次解析同一个正则表达式的时间。
             ret = re.compile('正则表达式')
             res = ret.search(str)

    finditer:   *****   ---节省空间
                ret = re.findtter(’正则规则“，str)    取值的方法 ：  .group()

    分组命名：  (?P<分组名>正则表达式)
                ret.group('分组名')
                约束分组，找标签：
                <(?P<tag>\w+)>.*?</(?P=tag)>    (?P=tag)  表示引用之前分组的内容。引用的不是正则表达式，而是前一个分组中的内容。

    分组的索引：  python中 \1 有特殊意义的，
                print('\1')   什么都没有，看不出来
                print(['\1'])   表示的是第一组的地址。 如果不希望发生转移的意思的话，直接 加上 r  就行了，取消了转义。

                <(?P<tag>\w+)>.*?</\1>    \1 但是由于其在python中有特殊的意义，那么应该修改如下
                r'<(?P<tag>\w+)>.*?</\1>'  ==   <(?P<tag>\w+)>.*?</\\1>

                print(r'\n') == print('\\n')
                '\\n'  怎么做呢，  正则：   \\\\n   ==  r'\\n'   \\\\n
                                                第一个 \ 主要是减去 \\n 里面第一个 \ 转义
                                                 第三个 \ 主要是减去 \\n  第二个  \ 转义的意思。

                总之，直接 加上 r  就行了

    有时候，我们要匹配的内容是包含在不想要的内容当中的，  那么。我们应该将其先全部取出来，然后再进行 去除不想要的内容。
怎么去除列表当中的空字符。


带参数的装饰器、递归函数

"""
import re
# 例一
ret = re.split('\d','alex2222wusir')
print(ret)
ret = re.split('(\d)','alex2222wusir')       # ['alex', '2', '', '2', '', '2', '', '2', 'wusir']
print(ret)
ret = re.split('\d+','alex2222wusir')
print(ret)
ret = re.split('\d(\d\d)\d','alex2222wusir')
print(ret)

ret = re.sub('\d','B','alex2222wus2345ir',3)
print(ret)

ret = re.subn('\d','H','aleox3445lsdgou3')
print(ret)

ret = re.match('\d+','alox234sugo456')
print(ret)

ret = re.match('\d+','123alox456ugo')
print(ret.group())

ret = re.compile('\d+')
res = ret.finditer('aso234ksoug-s99sksgs935')
for i in res:
    print(i.group())


print()
ret = re.search('\d\d(\d)(\w+?)\d\d(\d)(\w+?)\d\d(\d)(\w+?)\d\d(\d)(?P<试一试>\w+?)\d+','123ashog_45678ashog_123ashog_456789')

print(ret.group())
print(ret.group(5))
print('特地来试一试',ret.group("试一试"))

ret = re.findall('\d\d(\d)(\w+?)\d\d(\d)(\w+?)\d\d(\d)(\w+?)\d\d(\d)(\w+?)\d+','123ashog_45678ashog_123ashog_456789')
print(ret)



# ========================== python中 \1 ===================================
print('\1')
print(['\1'])


# 匹配整数：========================================================  存在不得不取出来的，先取值出来在操作
print(end='\n',)
print("数字匹配")
ret=re.findall('\d+',"1-2*(60+(-40.35/5)-(-4*3))")
print(ret) #['1', '2', '60', '40', '35', '5', '4', '3']   会将小数也分开取出来来了

ret=re.findall('\d+\.\d+|(\d+)',"1-2*(60+(-40.35/5)-(-4*3))")    # 我们一定要将所有的都取出来
print(ret)
# 为什么多一个空格呢？看这样       ['1', '2', '60', '', '5', '4', '3']

ret=re.findall('(\d+\.\d+)|(\d+)',"1-2*(60+(-40.35/5)-(-4*3))")    # 我们一定要将所有的都取出来
print(ret)      # [('', '1'), ('', '2'), ('', '60'), ('40.35', ''), ('', '5'), ('', '4'), ('', '3')]

ret=re.findall('\d+\.\d+|(\d+)',"1-2*(60+(-40.35/5)-(-4*3))")    # 我们一定要将所有的都取出来
print(ret)
print(list(filter(lambda n:n,ret)))  # 如果是空格，返回值为空，不是 n 就会将其筛选了


#  ==============================================================================

