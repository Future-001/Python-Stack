"""
========================================= 昨日回顾 =========================================
操作系统的历史：
    多道操作系统：
        遇到IO就切换
        提高 CPU 的利用率
        进程（内存中是隔离开的）
        时空复用：同一时间点上，多个程序同时执行，这一块内存条上存储了多个进程的数据
    分时操作系统：
        时间分片
        时间片的轮转

进程：
    计算机当中最小的资源分配单位:每个程序运行时需要分配一些资源（内存，寄存器...）
    pid
线程：
    计算机中能被CPU调度的最小单位：实际执行具体编译解释之后的代码的是线程，所以CPU执行的是解释之后的线程中的代码

并行和并发：
    并行：多个cpu，多个进程在多个cpu上同时执行
    并发：多个程序同时执行（微观上轮流在cpu上执行）

同步和异步：
    同步：调用一个操作，要等待该操作结束后才能执行之前的操作
    异步：调用一个操作，不等待直接继续执行

阻塞和非阻塞：
    阻塞：CPU不工作(IO)
    非阻塞：CPU工作

=========================================  今日大纲 =========================================
同步阻塞：
        input ,sleep recv recvfrom
        只要调用函数，都是同步的，毕竟都得等待返回值

同步非阻塞：
        eval

异步非阻塞：

异步阻塞：

===================================
进程的三状态图：
        就绪 运行 阻塞
            点击运行 =====> 操作系统接收到指令，分配一块空间给进程，创建对应的pid，====> 就绪====> 时间片轮转到开始执行(运行)
                运行====>可能存在的阻塞====> 阻塞结束====> 就绪状态====> 时间片运行====>如果时间片到了，没有运行完，继续等待就绪===> 运行 ===>结束
                    三角转换图： 就绪 运行 阻塞
                    例1 理解

进程的调度算法：
            给所有的进程去分配资源或者分配CPU使用权的一种方法
            短作业优先
            先来先服务 FXFS
        ### 多级反馈算法==>  含有短作业优先，先来先服务，时间片轮转，IO切换
        list = [ [进程1，进程2，进程3...],[],[] ... ]
                将所有进程放在一个列表（列表中每个元素又都是一个列表）里面，列表中的元素的位置(list[0] list[1]) 代表他们的优先级，
                优先级从高到低排序,CPU根据优先级从高到低执行，对列表中的第一个列表中的第一个元素(进程1)执行完一个时间片之后
                将该进程的优先级下降， list = [ [进程2，进程3...],[进程1，.....],[] ... ]
                即将该进程存储到第二个列表当中，然后执行第一个列表中的原来的第二个元素(进程2),
                所有的列表元素都得等list[0]的进程都执行之后，才开始执行，如果在执行list[3]中的进程时候，list[0]来了另一个元素，那么
                立即停下执行list[3]开始执行list [0】中的元素
                每个list中的元素执行时间不一样 list[0]可能一个时间片，list[2]可能三个时间片

            多个任务队列，优先级从高到低
            新来的任务总是优先级最高的
            每一个新任务几乎会立即获得一个时间片时间‘执行完一个实际那片之后就会降到下一级队列中
            总是优先级高的任务都是执行完才开始执行优先级低的队列
            优先级越高，时间片越短

进程的开启和关闭：
    1. 系统初始化（查看进程linux中用ps命令，windows中用任务管理器，前台进程负责与用户交互，后台运行的进程与用户无关，
        运行在后台并且只在需要时才唤醒的进程，称为守护进程，如电子邮件、web页面、新闻、打印）
　　2. 一个进程在运行过程中开启了子进程（如nginx开启多进程，os.fork,subprocess.Popen等）
　　3. 用户的交互式请求，而创建一个新进程（如用户双击暴风影音）
　　4. 一个批处理作业的初始化（只在大型机的批处理系统中应用）
　　无论哪一种，新进程的创建都是由一个已经存在的进程执行了一个用于创建进程的系统调用而创建的。　　

　  1. 正常退出（自愿，如用户点击交互式页面的叉号，或程序执行完毕调用发起系统调用正常退出，在linux中用exit，在windows中用ExitProcess）
　　2. 出错退出（自愿，python a.py中a.py不存在）
　　3. 严重错误（非自愿，执行非法指令，如引用不存在的内存，1/0等，可以捕捉异常，try...except...）
　　4. 被其他进程杀死（非自愿，如kill -9）
"""
# ============例1===================
# 就绪，等待调度时间片
import time

print("运行态")

name = input("到达阻塞态 >>> ")
# 输入结束后,进入就绪态，等待操作系统调度
print("又转到了运行态",name)
time.sleep(1)  # 阻塞态
# 就绪态
print("运行态   ")
# 结束

# ============例2===================