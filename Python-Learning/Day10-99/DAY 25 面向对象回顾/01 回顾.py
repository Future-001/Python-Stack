"""
========================================= 内容回顾 =========================================
对象：
    对象=类名()
怎么用：
    类有什么用：
        1.实例化对象
        2. 能操作静态变量
    什么时候对类中的变量赋值，或使用类中的变量：
        类名.名字 ='值'
            类名.名字  对象名.名字（如果对象中没有，去类中找)
    什么时候对对象中的变量赋值：
        对象.名字    self.名

实例化的时候，总是先开空间，在调用 __init__的时候，总是把新开空间作为参数传递给 self

实例化对象里面的内容：    类指针--> 指向了 类的地址。
                       是没有函数名的，函数名是在类的空间里面的

所有的类的调用方法，就看这个对象是哪一个类的对象
不要担心所有的类的方法可能有同名，并不会相互影响

如何继承：
        class B(A): pass
        代码的的时候，先有父类还是子类？  加载代码的时候，肯定是先写父类
        思考的时候，先把子类写完，发现重复的代码，再将重复的代码放到父类当中。

        自己有，用自己的方法，自己没有用父类的方法
        自己有，父类也有，用自己的
        既想用自己的，又想用父类的，  父类.函数名(self,,,)

    注意一个静态变量的问题，尽量不要用       对象.静态变量
    静态变量是存储在类的空间里面的，是公用的。
=========================================  今日大纲 =========================================
实例化对象的内存空间里面到底有些什么东西：
        静态变量：  除非静态变量是可变的，不然对静态变量修改， 对象的空间里只是指向了别的变量，不会影响原来类的静态变量
        __init__ 函数下面的内容，在对象里面都有，
        函数名不在对象的空间当中，只在类的空间中。
        如果静态变量可变： 那么，该静态变量修改后，相当于静态变量所有的值都改变了，那么对象所指向的是同一静态变量

"""
class A:
    role = 'student'
    def __init__(self):
        self.l=[]
    def append(self,obj):
        self.l.append(obj)
    def pop(self,index=-1):
        self.l.pop(index)
print(A.role)
a=A()
a.role='111'
print(a.role)
print(A.role)