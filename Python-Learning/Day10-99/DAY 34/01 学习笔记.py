"""
====================================昨日回顾=============================================
开启进程的另一种方式：
    面向对象的方式，
    传递参数的方法  __init__  run 这两种方法

守护进程：
    p.daemon = True
    等到主进程代码结束之后立即结束
    主进程回收子进程的资源，主进程一定在守护的子进程之后结束

锁
    lock.require()   lock.release()   with lock
    功能： 保证的数据的安全，（数据之间有一些共同的操作，不然内存是隔离的），数据效率降低了
    互斥锁

队列
    ipc 进程间通信，主要用于信息传递，
    基于socket实现的的，基于pickle实现的（json 不能传集合），基于lock 实现的，数据安全
    pipe 管道（基于socket 和pickle 实现的，没有锁 数据不安全，不太用了)

生产者消费者模型
    将原本获取数据处理数据的完整过程进行了解耦，就是逻辑性是不是很清晰，代码是不是各个部分都很清楚
    将生产数据和消费数据分开，根据生产和消费的效率不同，来规划生产者和消费者的个数
        让程序的执行效率达到平衡


同步阻塞：
    调用函数必须等待结果，cpu没工作  input sleep  recv accept connect  get
同步非阻塞
    调用函数不用等待结果 eval CPU工作  strip  sum  max min sorted
异步阻塞
    看02的例子得了,调用函数不需要立即获取结果，继续执行下面的代码，获取结果得时候不知谁先来，但是总之需要等
异步非阻塞
    调用函数不需要立即获取结果，也不需要等 start()  terminate()

====================================今日内容==============================================
进程的内容
    生产者消费者模型
        爬取网页
    数据共享
        Manager类
            本来进程间数据是隔离的，不能共享，Manager类就是用用来做数据的共享的,时间比较久，数据不安全，并发执行
            加锁，但是很慢，用的很少

进程： 数据隔离，资源分配的最小单位，可以利用多核，操作系统调度，开启关闭切换时间开销大
    multiprocessing  如何开启进程  start  join
    进程之间数据不安全的问题  Lock（抢票的例子)
    进程之间可以通信Ipc:
        队列， 管道
                生产者消费者模型
        第三方工具
    进程之间的数据共享Manager
    开启的进程数一般不会超过CPU个数的两倍

线程的概念:
        能被CPU调度的最小单位， （一段一段执行的是指令集，不是线程）
        一个进程里可以有多个线程
        同一个进程中的多个线程同时被CPU执行？ ====> 就是这样的，可以利用多核
        数据是共享的，操作系统调度的最小单位，利用多核，操作系统调度，数据不安全，时间开销小，

Cpython中的线程的特点
    gc 垃圾回收机制：  线程
        引用计数 + 分代回收
    全局解释器锁(GIL global  interpreter lock)
        它的出现主要是为了完成gc 的引用计数的回收机制，对不同线程的引用计数一次只能由单个线程执行
            导致了同一个进程中的多个线程只能有一个线程被CPU执行
        节省的是 IO操作的时间（IO操作CPU不工作，不锁）而不是CPU计算的时间，计算效率很快


        Cpython,pypy 中不能用多核，主要都是因为其中的垃圾回收机制不同
        jpython 可以利用多核

threading模块开启线程
        和进程模块的使用一摸一样 ， Thread 参数一样，join , start 方式
        线程无法从外部关闭，所有的子线程只能是执行完参能关闭，所有没有 terminate
        线程内部获取线程id  current_thread()   得到一个对象，具有  ident属性
        enumerate()  列表 存储了所有活着的线程对象，包括主线程
        active_count()   数字 存储了所有活着的线程的个数

        面向对象的方式起线程
        和进程一摸一样，别忘记了 super 继承

        可以去利用 锁，不然数据共享很快就能修改数据，数据也不安全。。。。
"""
