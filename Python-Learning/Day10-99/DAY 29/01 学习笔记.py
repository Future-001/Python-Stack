"""
========================================= 昨日回顾 =========================================
概念：
    B/S  C/S架构
    OSI 七层模型：
    五层模型：各层有些什么实体
=========================================  今日大纲 =========================================
TCP协议：
        多次通话
        接受多个客户端的请求
UDP协议的编程： SOCK_STREAM = 1
              SOCK_DGRAM = 2   这是UDP的。默认参数如下
               socket.socket(family=AF_INET, type=SOCK_STREAM, proto=-1, fileno=None)   -1表示默认参数

粘包现象：    只出现在   TCP
         分别发送的数据，连接到一起了，================> 数据乱了
         发送的数据，TCP先在操作系统缓存，再通过硬件发送出去，提高了发送效率
         接收端收到了消息，由于某种原因有一些延迟，没有及时收到用户发送的消息，导致后一条消息和前一条消息粘在一起了。

            原因可能有：： 发送端发送的消息很短，间隔时间也很短。
                        接收端 接收消息不及时。

        为什么TCP会有粘包，UDP不出现呢？ TCP能发大文件，UDP不可以发送大文件（ 网络带宽限制，无连接 ）
                数据之间没有边界，TCP发送大文件时，将一个个包分开传输，最后再进行粘连，有边界的话拼接起来比较麻烦
                步骤： 拆包，编号，确认收到，没收到重发，====>  拼接

解决粘包问题的本质：
            边界问题，怎么确定发送的边界。
            自定义协议： 规定每一次发送的数据的长度。
                  str(len(xxx)).zfill(4).encode("utf-8")  接受发送的长度： sk.recv(4).decode("utf-8")
            但是最多显示 9999 个字节

     引入  struct 模块，将发送的（任意）数据转为固定的 4 个字节的长度（同时已经进行了编码）
     struct.pack('i',发送的数据长度)
     struct.unpack('i',接收到的数据长度)
        注意：接收到的数据长度是一个元组。第一个元素是你接收到的的数据的长度

struct.pack("format  --即要发送的数据的数据类型",*aregs)   *args 代表了你要发送的数据的长度
最终的返回值是一个字节类型的
length = struct.pack("i",len(msg))
conn.send(length)
conn.send(msg)
"""


print("   ===========================给字体加上颜色：============================ ")
print("\033[31m 可以改变字体的颜色  31 ---    这是一行的")
print()

print("\033[35m  这是可以多行的")
print("     同时改变多行的颜色")
print("     听起来不错嘛,结束符是 \033[0m")

print()
print("\033[1;34;41m  关于前景色和背景色：  30 --37 前景色")
print("     背景色： 40---47")
print(" --- 显示方式："
      "0    终端默认设置"
      "1    高亮显示"
      "4    使用下划线"
      "5    闪烁"
      "6    反白显示"
      "7    不可见")