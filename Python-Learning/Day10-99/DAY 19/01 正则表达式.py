"""
========================================= 昨日回顾 =========================================
软件开发规范。大作业。 以后的大作业，一定一定要按照模块的东西来讲

=========================================  今日大纲 =========================================
模块和实际工作时间的关系：
        正则表达式： *****  很重要很重要很重要
                        自动化运维 --- 开发
                        爬虫
                        日志分析

        time模块和时间的关系：
                time模块为了更方便的让我们操作时间，也可以说二者没关系。
        re 模块和正则表达式的关系：
                有了 re 模块就可以在python语言中操作正则表达式了。（re 本身没有任何规则，只是让你用正则表达式）

正则表达式：
        超级好用的工具：  https://tool.chinaz.com/regex/
        一套规则： 用于匹配字符串，（只是 字符串）

        能做什么：
                1. 检测一个输入的字符串是否合法
                        用户输入一个内容的时候，我们要提前做检测
                        这样能提高程序的效率并且减轻服务器的压力
                        例如： 京东账号的注册，都不是电话号码，怎么可能给你发验证码
                2. 从一个大文件中找到所有符合规则的内容
                        例如，从一百万行文档里面找到电话号码，从第一个检测，直到能够顺利的取到10个数字。不满足条件，不存储
                        正则可以高效的从一大段的文字中快速找到符合规则的内容。

        正则规则：
            所有的规则中的字符就可以刚好匹配到整个字符串中符合规则的内容
            字符组：  []  描述的是一个位置上 能出现的 所有可能性  就是能匹配的东西
                    接受范围:可以描述多个范围，中间没有 ，或；
                    一个中括号表示匹配一个！一个！字符的位置
                    [abc] 表示匹配到 a或者b 或者 c                   [0-9]  表示匹配到 0-9 之间的一个 一个，一个数字
                    就算下面的字符串同时出现了  129843045   但是也只表示它能够匹配其中的一个，并不是全匹配了
                    [0-9]  没有逻辑的，其实是根据ASCII来匹配内容的。所以可以写  [a-z]  [A-Z]  只能从小到大
                    注意 [A-z]  会将其中的所有字符都匹配商
                    还可以 [a-z0-9A-Z] 只能 - 左右有要求，中间没有任何要求。而且只是 - 两边大小要求，别的没有

                    \d  == [0-9]   digit
                    \w  == [0-9a-zA-Z_]   数字字母下划线    word
                    \t   \n   ==     空白（空格，tab 换行 ） =====>  \s  匹配所有的空白

        在正则表达式中能够帮助我们表示匹配的内容的符号，都是正则中的 元字符：  例如 \d \s \w
        \d                                \t   \n
        \w
        \s
        \W  非字母数字下划线
        \D  非数字
        \S  非空白符
        [\d]   ==  \d
        [\d\D]  相当于匹配所有的东西   [\s\S]   [\W\w]
        .  也是匹配除了换行符之外的所有，但是也可以通过设置，配置所有
        [^]   表示非字符组 ，意思是只要不是后面的东西就可以匹配上   [^1]  匹配所有不是1的字符
        ^  表示匹配一个字符串的开始     例如 ^a.
        $ 表示匹配一个字符串的结尾      a.$
                                    ^a.$  能匹配到什么？===>
                                    a^al.$ 根本不可能，
        |   或  ad|bc   但是 ab|abc 左边匹配上了之后，右边就匹配不上了，所以一定将长的放在前面
                        abc|ab    如果规则有重叠部分，那么就将长的放在前面
        \   表示取消一个东西的特殊意义   例如   www.baidu.com    匹配上了 www;baidu;com
                                    改一下：   www\.baidu\.com
        分组的作用，      www\.(jingdong|taobao)\.com   这样就可以或
        x\b   表示一个匹配单词的边界的东西, 规则 是x

        记忆元字符： 都是表示能匹配哪些内容，一个元字符总是表示一个字符位置上的内容。
                练习：  两位整数    [1-9]\d
                        精准约束以及 宽泛约束 那么匹配100个呢？

        量词：
        {n}      表示匹配 n 次
        {n,}    表示 至少匹配n 次
        {n,m}   至少 n 次 至多 m 次
        ?      表示匹配0次或1次
        +     表示匹配1次或多次
        *     表示匹配0次或多次
                        匹配一个整数  ：  \d+   一个小数：  \d+\.\d+   整数或小数：  \d+\.?\d*  但是这样的话 17588.  也能匹配上了

        分组的作用：  \d+(\.\d+)?

                练习题： 手机号码  1 3-9   11位
                            1[3-9]\d{9}   但是注册的时候，可能连续输入了22位，有问题了    ^1[3-9]\d{9}$  约束不能多也不能少
                            一定要注意是不是要加  ^  $

        贪婪匹配现象： \d{3,9}   一般优先 9 次     \d{3,}7  他会一直到最后一个7 才会停止，就算之前有7 也不管
                    回溯算法。
        惰性匹配： （非贪婪匹配算法）  在量词后面加上 ？ 表示非贪婪，找到第一个就可以了   \d{3,}?6  表示j尽量少的进行匹配
                                一定要注意在量词后面才表示非贪婪。
                  .*?x          表示匹配任意字符，任意多次，直到x 才停下来   .*x  表示匹配任意字符，任意次数，直到最后一个x

        转义符： 原本有特殊意义的字符（.()*?+)等等，，到了表达它本身的时候，一定要注意转义
                转义的方法：   \   或者   []  将其放在 [] 中能取消他的特殊意义
                            [.]    [().*+?]
                            [a\-c]   - 在字符组中表示范围，如果不希望他表示范围那么应该对其进行转义 或放在 字符组最前面或最后面。
                注意：  [\d\w\D]等在字符组里还是表示它原来的特殊意义



正则 re 模块：---- regex 正则表达式
        re模块好像有点难度的。有周末作业。
        ret = re.finadll('正则表达式',str)   这个会找到 所有的符合条件的东西,最终得到一个列表，
        ret = re.search('正则表达式',str)    只会找到 第一个 就返回，取值   ret.group()
                                            用 group 取值，本质上和正则表达式分组有一定的关系。
                                            注意，找不到就报错

        re 模块与分组的关系： (看例子理解）
                findall: 还是按照完整的正则进行匹配，匹配到了所有的结果，不过，它只是优先显示了分组中匹配到的内容。
                            总是只显示括号里 匹配到的内容。

                search:  按照完整的正则进行匹配，显示匹配到的 第一个 内容（不只是分组里面的内容)，但是我们可以通过
                            group  方法传递参数来获取具体分组 中的内容。  就是这样的 (\d)(\d)  ret.group(1)   ret.group(2)
                                    依次2取括号内的数值

                findall:
                        获取所有符合条件的，优先显示分组中的。
                search:   只取第一个符合条件的，没有优先显示这回事儿。
                    得到的是一个变量
                        变量.group()  的结果，万泉河  变量.group(0） 结果一致
                        变量.group(n) 的形式来指定获取第 n 个分组中匹配到的内容，

                加上括号，是为了真正需要的内容 进行提取，这样就只获取到有作用的东西

分组的意义，为什么要用分组，以及 findall 的好处：
            如果我们所要查找的内容在一个复杂的环境中，我们要查找的内容没有一个突出的，与众不同的特点，升值回合不需要的杂乱的数据混合在一起
            这个时候我们就需要把所有的数据都统计出现，然后对这个数据进行筛选，把我们真正需要的数据
            对应的正则表达式 用 ()  圈起来

            如果有 多个分组，那么这些个东西，可以取消优先显示 ，  (?:xxx)   那么就取消优先显示这个内容。

什么是爬虫：通过代码获取到一个网页的源码。  from  request
分组和findall 现象，
如何取消分组优先:
            如果再写正则表达式的时候，由于不得已的原因，导致不要的内容也得写在分组里
            (?;） 就被用来取消分组优先
"""
import re
ret = re.findall('\d','sa89slgo344d')
print(ret)
ret = re.search('\.s','sgak.sga')
print(ret)
print(ret.group())

print()

# ======================================= 分组  re模块  ===============================================
ret = re.findall('8(\d)\d','19848shaig1890')
print(ret)
ret = re.search('8(\d)\d','19848shaig1890')
if ret:         # group 找不到就报错
    print(ret.group())
    print(ret.group(1))

print()
ret = re.findall('\w+',"<h1>ask234zlxovu445<h1>")
print(ret)

ret = re.findall('<\w+>\w+<\w+>',"<h1>ask234zlxovu445<h1>")
print(ret)

ret = re.findall('<\w+>(\w+)<\w+>',"<h1>ask234zlxovu445<h1>")
print(ret)

ret = re.search('<\w+>(\w+)<\w+>',"<h1>ask234zlxovu445<h1>")
if ret :
    print(ret.group())
    print(ret.group(1))


print()

# import requests
# ret = requests.get('https://movie.douban.com/top250?start=0&filter=')
# print(ret.content.decode('utf-8'))
#
# ret = requests.get('https://www.baidu.com/')
# print(ret.content.decode('utf-8'))

print()
c = '2-3*(5+6)'
ret = re.findall('(\d+)[+](\d+)',c)
print(ret)

ret = re.search('(\d+)[+](\d+)',c)
if ret:
    print(ret.group())   # 删选第一个符合正则条件的 结果
    print(ret.group(1))
    print(ret.group(2))
    print(int(ret.group(1))+int(ret.group(2)))

print()

with open('douban.html',encoding = 'utf-8') as f:
    content = f.read()
ret = re.findall('<span class="title">(.*?)</span>\s*(?:<span class="title">.*?</span>)?',content,)
                # flags=re.S 表示 . 也能匹配所有的
                # 刚开始  <span class="title">(.*?)</span>\s*<span class="title">.*?</span> 霸王别姬不太一样
                # 它默认是贪婪匹配了，那么我们就对其有的进行匹配，没有的不匹配，然后优先级的话，修改后面的现实优先级
print(ret,len(ret))




